---
format:
  chribel-summary-quarto-pdf:
    include-in-header:
    - text: "\\usepackage[datesep=.]{datetime2}"
    - text: "\\DTMsetdatestyle{ddmmyyyy}"
    - text: "\\usepackage{blindtext}"
    toc: true
    classoption: twocolumn

# [DOCUMENT INFORMATION]
title: "Advanced Reliable Embedded Systems"
subtitle: "ARES"
author: "Andi Ming"

# [PAGE OPTIONS]
lang: en-GB
babel-lang: ukenglish

# [HEADER & FOOTER]
fancyhdr:
  header:
    right: "Advanced Reliable Embedded Systems"
    center: ""
    left: "HSLU"
  footer:
    right: "ARES"
    center: "\\thepage\\ / \\pageref{LastPage}"
    left: "\\today"
  
source:
  github: "https://www.youtube.com/watch?v=VGhcSupkNs8"

accentcolor: "124E82" # must be given as hex, sadly :(

chribel-fontfamily:
  - name: AlegreyaSans      # used for section headings, title page
  - name: cmbright          # used for paragraph and math
  - name: inconsolata
    options: "scaled=0.95"  # for code blocks
---

# Safety, Risiko Management

::: callout-important
## Safety \| Safety-Critical

**Safety** is defined as preventing harm to humans/environment, while **safety-critical systems** ensure this property.
:::

::: callout-important
## Risk \| Safety-Integrity

**Risk** is a measure of the likelihood, and the consequences, of a hazardous event.

**Safety-integrity** is a measure of the likelihood of the safety system correctly performing its task.
:::

## Terms

-   **Hazard**: A situation in which there is actual or potential danger for people or environment.
-   **Accident**: Unintended event harming people or environment.
-   **Incident**: Unintended event which does not harm, but has the potential to do so.
-   **Risk**: Likelihood of hazard occurrence, and the likely consequences. $\text{Risk} = \text{Severity} \times \text{Probability}$
-   **Fault**: Defect in system. Can be **random** or **systematic.**
-   **Error**: Deviation from the required operation of the system.
-   **System Failure**: Occures when system fails to perform its required function.
-   **Casualities** (Kausalitäten): The presence of a fault *may* lead to an error, which *may* lead to a system failure, which *may* lead to an accident.

## Requirements

Requirements give a system the properties of **integrity and dependability**.

This demands: (1) **Safety**, (2) **Reliability**, (3) **Availability**, (4) **Maintainability**.

::: callout-warning
## Conflicts

In general, the various requirements to a system are conflicting among themselves.
:::

### Process (Iterative!)

1.  Identification of hazards associated with the system
2.  Classification the hazards
3.  Determination of methods to deal with hazards
4.  Assignment of reliability and availability requirements
5.  Determination of safety integrity level
6.  Specification of development method appropriate to integrity level

## Verification, Validation & Certification (V&V&C)

-   **Verification**: Confirms system meets specifications
-   **Validation**: Ensures fitness for intended purpose
-   **Certification**: Obtains regulatory approval through evidence documentation
-   Key distinction example: Medical device passing lab tests (verification) but failing clinical trials (validation)

## Hazard & Risk Analysis

-   **Hazard identification** methods:
    -   *FMEA* *(Failure mode and effects analysis)*: Analyzes component failure effects on ultimate consequences.\
        ![](images/paste-1.png)
    -   *HAZOP (Hazard and operability studies)*: Uses guidewords to detect operational deviations.\
        ![](images/paste-2.png)
    -   *ETA (Event tree analysis)*: Model effects from starting point forward to determine possible consequences.\
        ![](images/paste-3.png)
    -   *FTA (Fault tree analysis)*: Identify hazards and determine their possible causes.\
        ![](images/paste-4.png)

## Risk Analysis

-   **Risk classification** combines severity (catastrophic/negligible) and frequency (frequent/incredible). Risks are categorized as intolerable (I) to negligible (IV).

$$
\text{Risk} = \text{Severity} \times \text{Probability}
$$

![](images/paste-5.png){fig-align="center" width="7cm"}

### Severity of Hazardous Event

![](images/paste-6.png){fig-align="center" width="8cm"}

### Frequency of Hazardous Event

![](images/paste-7.png){fig-align="center" width="8cm" height="3cm"}

### Risk Classification

![](images/paste-8.png){fig-align="center" width="8cm"}

### Integrity Classification

**ALARP-Rule**: Class II & III is only acceptable if it is **A**s **L**ow **A**s **R**easonably **P**racticable

Risk can be reduces by safety features. Achieved reduction depends upon integrity of these features.

Safety integrity is how likely a safety system is to perform its job correctly, under all conditions, and for the required time.

#### Safety Integrity Levels (SIL)

![](images/paste-9.png){fig-align="center" width="8cm"}

### Hardware Integrity

**Hardware integrity** is that part of the safety integrity relating to dangerous *random* hardware failures.

### Systematic Integrity

**Systematic integrity** is that part of the safety integrity relating to dangerous *systematic* failures.

### Software Integrity

**Software integrity** is that part of the safety integrity relating to dangerous *software* failures.

## Achieving Safety Integrity

The process involves iterative design stages and layered fault mitigation strategies to meet safety-critical system requirements.

### Core Design Process

1.  **Abstraction**: Identify essential system properties
2.  **Decomposition**: Break systems into analyzable components
3.  **Elaboration**: Add implementation details
4.  **Decision**: Select optimal design alternatives

### Fault Mitigation Strategies

Four complementary approaches:

1.  **Avoidance**: Prevent faults during design phase
2.  **Removal**: Eliminate faults through testing/reviews
3.  **Detection**: Identify faults during operation
4.  **Tolerance**: Maintain functionality despite faults

### Fault Characteristics

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Category} & \textbf{Types} & \textbf{Examples} \\
\hline
Nature & Random (HW) vs Systematic & $\alpha$-particle errors vs spec bugs \\
\hline
Duration & Permanent/Transient/Intermittent & Broken chip vs cosmic rays \\
\hline
Extent & Localized vs Global & Single sensor vs power failure \\
\hline
\end{tabular}
\end{table}

**Hardware Fault Tolerance:**

-   **Static** (TMR/NMR): Mask faults via majority voting (3-5 modules)
-   **Dynamic**: Detect & switch to backups
-   **Hybrid**: Combine masking + reconfiguration

**Software Fault Tolerance:**

-   **N-version Programming**: Parallel diverse implementations (Airbus/Shuttle)
-   **Recovery Blocks**: Fallback modules with acceptance tests
-   **Information**: Additional data (parity / checksum)
-   **Temporal**: Repeat calculations

### Key Challenges

-   Common-mode failures require **diversity** in:
    -   Implementation methods
    -   Programming languages
    -   Hardware platforms
-   **Systematic faults (spec/design errors)** are harder to mitigate than random HW faults
-   No single technique provides complete protection

**Critical Insight**: Achieving safety integrity requires combining multiple fault mitigation strategies through iterative design refinement, as perfect fault elimination is impossible in complex systems.

**Detection**: Functional checking, Consistency checking, Signal comparison, Checking pairs, Information redundancy, Instruction monitoring, Loopback testing, Watchdog timers, Bus monitoring, Power supply monitoring

## Fault Tolerance

-   **Redundancy strategies**:

    -   *TMR (Triple Modular Redundancy):* Voting systems mask faults via majority logic (3 modules)

![](images/paste-15.png)

![](images/paste-16.png)

![](images/paste-17.png)

-   *NMR:* Voting systems mask faults via majority logic (3-5 modules). Allows for $\frac{N-1}{2}$ modules to fail

![](images/paste-18.png)

-   *Dynamic redundancy*: Switches to backup modules after fault detection.

![](images/paste-19.png)

-   *Self checking pair*: The outputs are compared and give indication of failure

![](images/paste-20.png)

-   **Diversity**: Combines different implementations/languages to avoid common-mode failures.

-   **Software fault tolerance**: Uses *N-version programming* (parallel implementations) or *recovery blocks* (fallback modules with acceptance tests).

## Reliability

::: callout-note
## Reliability

Reliability $R$ is the probability of a component or system functioning correctly over time $R(t)$. Describing a statistical behaviour of a component or system.

Given: Period of time, set of operating conditions.

$$
R(t)=\frac{n(t)}{N}
$$

with $n(t)$ number of working elements, and $N$ number of original elements.
:::

::: callout-warning
## According to DoD MIL-Handbook

The reliability prediction according to the **MIL-Handbook** (US) is not followed and maintained anymore because of to many unknown variables.
:::

### Unreliability

Probability $Q(t)$ that a system will **not** function over a given period of time. $Q(t)+R(t)=1$

$$
Q(t)=\frac{n_f(t)}{N}=1-R(t)
$$

with $n_f(t)$ number of failed components at time $t$.

### Failure Rate

The rate $z(t)$ at which a device fails

$$
z(t)=\frac{1}{n(t)}\cdot\underbrace{\frac{dn_f(t)}{dt}}_{Failures}
$$

![](images/paste-21.png){fig-align="center" width="7cm"}

For a constant **failure rate** $z(t)=\lambda$ the probability of a system working correctly decreases exponentially

$$R(t)=e^{-\lambda t}$$

### Time-Variant Failure Rates

Software failures which are systematic and correctable the failure rate decreases with time. **Weibull** distribution

$$
R(t)=e^{-\left(\frac{t}{\eta}\right)^\beta}
$$

![](images/paste-24.png){fig-align="center" width="6cm"}

## Mean Times

### Mean Time to Failure

Expected time before first failure

$$
MTTF=\int_{0}^{\infty}R(t)dt=\frac{1}{\lambda}
$$

::: callout-caution
## Reliability

With $\lambda=0.001$ failure/h $MTTF=1000h$.

But at $t=1000h$ the reliability is only $R(t)\approx0.37$ (chance for running at 1000h mark is 37%)
:::

### Mean Time to Repair

Time to repair given by repairability $\mu$

$$
MTTR=\frac{1}{\mu}
$$

### Mean Time Between Failures

$$
MTBF=MTTF+MTTR
$$

### Failure in Time

Number of failures expected in $1\times10^9h$ of cumulative operation hours

$$
FIT=1\times10^9\cdot\frac{1}{MTBF}
$$

## Reliability Modelling

### Series Systems

Failure of **any** **component fails**

$$
R(t)=R_1(t)\cdot R_2(t)\cdots R_N(t)=\prod_{i=1}^N R_i(t)
$$

$$
\lambda=\lambda_1+\lambda_2+\cdots+\lambda_N=\sum_{i=1}^N\lambda_i
$$

### Parallel Systems

System operational as long as **one component is functioning**

$$
R(t)=1-Q(t)=1-\prod_{i=1}^N(1-R_i(t))
$$

### Redundancy

![](images/paste-25.png)

# 

![](images/paste-26.png)

![](images/paste-27.png)

![](images/paste-28.png)

::: callout-warning
## Reliability Prediction

There is extensive (usually MIL std.) literature but often with lots of unknown variables.
:::

::: callout-important
## Reliability Assessment

How to proof that a system fails less then once in $1 \times 10^9$ hour (i.e. $\approx$ 100 000 year) of operation?

Trust the development techniques.
:::

## Software Safety

Common faults:

Coding faults, logical errors within calculations, numeric under- and overflows, stack under- and overflows, range under- and overflows (arrays!), uninitialised variables, unintended side effects, truncation by casts, rounding effects, memory leaks, ...

### Capablity Maturity Model (CMM)

![](images/paste-29.png){fig-align="center" width="6cm"}

*LOC: Lines of Code*

### Formal Methods

Apply mathematically rigorous techniques for the specification development and verification of the software and hardware systems.

![](images/paste-30.png){fig-align="center" width="7cm" height="2.6cm"}

### Frama-C

-   Frama-C is an open source framework
-   core to read C files and build abstract syntax trees
-   set of plug-ins to do static analysis and to annotate syntax trees
-   plug-ins can collaborate, i.e. use another plug-in
-   plug-ins programmend in OCaml language
-   major plug-ins: EVA & WP
-   ACSL (ANSI/ISO C Specification Lanugage) for annotations by C comments /\* \@ ... \*/

![Frama-C plug-ins](images/paste-33.png){fig-align="center" width="9cm" height="4.5cm"}

### Evolved Value Analysis (EVA)

Computes variation domains for variables, determine bounds for the values of variables and function results.

![](images/paste-31.png)

### Weakest Precondition (WP)

Proofing certain properties, tries to proof the properties defined.

![](images/paste-32.png)

::: callout-note
## Missing RTE guards

In this example the specification is met as long as *no runtime error* is issued (see warning `Missing RTE guards`). Add the flag `-wp-rte` to add additional conditions.

It can not be guaranteed that no overflow could occur.
:::

::: callout-important
## High integrity software

High integrity software is possible, but this demands a lot of **efforts** and **passion** from it's developers.
:::

# Encryption

::: callout-note
Wenn Daten Sequenzen in Blöcke geteilt werden (z.B. 64-Bit), dann wird davon ausgegangen, dass bei unvollständigen Blöcken die restlichen Bits mit z.B. `0` augefüllt werden.
:::

::: callout-important
## Sicherheit beweisen

Sicherheit kann nicht bewiesen werden, unsicherheit schon!
:::

## Cesar Cipher / Substitution Cipher

![](images/crypto/ceaserCipher.png)

Buchstaben werden um $x$ Positionen verschoben (z.B. `A`$\overset{+2}{\rightarrow}$`C`). Nachteil ist, dass die Entschlüsselung sehr einfach ist.

## Enigma Maschine [\color{BrickRed}\faYoutube](https://www.youtube.com/watch?v=ybkkiGtJmkM)

Die Enigma Maschine ist ein komplexes Ent- & Verschlüsselungs System, welches während den Weltkriegen von den Nazis hauptsächlich verwendet wurde (und durch Alan Turing geknackt).

![](images/crypto/enigma.pdf)

Nachjedem Tastendruck leuchtet ein Buchstabe auf und die Rotoren drehen sich, damit der nächste gleiche Tastendruck nicht den gleichen Buchstabe ergibt. Mit den Steckern können die Buchstaben umkonfiguriert werden (bei Doppelstecker wird z.B. $A\rightarrow B$ & $B\rightarrow A$ und dadurch halbiert sich die Möglichkeiten zu 13).

## Stream & Block Cipher

![](images/crypto/block_stream_cipher.pdf){fig-align="center"}

## Konfusion

Konfusion ist eine Verschlüsselungsoperation, bei der die **Beziehung zwischen Key und Ciphertext verschleiert** wird. Ein gängiges Element zur Erzielung von Konfusion ist heute die Substitution.

Konfusion erhöht die Mehrdeutigkeit des Ciphertextes und wird sowohl von Block- als auch von Stream-Ciphern verwendet.

## Diffusion

Diffusion ist eine Verschlüsselungsoperation, bei der der Einfluss eines Klartextsymbols auf viele Ciphertext-Symbole verteilt wird, um die statistischen Eigenschaften des Klartextes zu verbergen.

## Feistel Network [\color{BrickRed}\faYoutube](https://www.youtube.com/watch?v=FGhj3CGxl8I)

Ein Feistel Netzwerk wird zum Ver- und Entschlüsseln von Datenpaketen verwendet. Folgend ist ein symmetrisches Feistel Netzwerk $\rightarrow$ Datenblock wird halbiert (64-Bit $\rightarrow$ 2 $\times$ 32-Bit). Eine Runde entspricht:

$$
\begin{split}
  L_n &= R_{n-1}\\
  R_n &= f(L_{n-1},k_n)
\end{split}
$$

![](images/crypto/feistel_network.pdf){fig-align="center" width="4cm"}

Funktion $f$ ist **wichtig**. Wenn diese sicher gegen Attacken ist, dann wird das Feistel Netzwerk mit jeder Runde und Key-Segment sicherer!

::: callout-important
### Ver- & Entschlüsseln

Verschlüsselte Informationen können mit dem genau gleichen Ablauf wieder entschlüsselt werden.
:::

## XTEA

e**X**tended **TEA** ist eine Erweiterung von TEA, welcher die Verschlüsselung besser macht. Gleiche Eigenschaften + Konstantwert `delta=0x9E3779B9`.

![](images/crypto/XTEA_InfoBox_Diagram.png){fig-align="center" width="6cm"}

Combination of mathematical (*addition*) and non-mathematical (*shift*) operations comes from *IDEA* (developed at ETH).

``` c
void encipher (unsigned int num_cycles, uint32_t v[2], uint32_t const k[4]) {
    unsigned int i; 
    const uint32_t delta = 0x9E3779B9; //decipher changes: 
    uint32_t v0 = v[0], v1 = v[1], sum = 0; //, sum = delta * num_cycles; 
    for (i=0; i < num_cycles; i++) {
        v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]); //-= 
        sum += delta; //-=, exchange lines above and below 
        v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]); //-= 
    }
    v[0] = v0; v[1] = v1;
}
```

::: callout-important
### XTEA sicher?

XTEA ist ein sicherer Verschlüsselungsalgorithmus, wenn auch nicht so sicher wie RSA oder andere.
:::

## Advanced Encryption Standard (AES)

Die US National Institute of Standards and Technology (NIST) hat in 1977 neuen *Advanced Encryption Standard* (AES) präsentiert und verschiedene Blockcipher wurden evaluiert. *Rijndael* 'gewann' die Runden in 2001 und wurde zu AES umbenannt.

AES ist ein Byte-orientierter Cipher!

::: callout-note
#### Anforderungen & Kandidaten

**Anforderungen**

-   block cipher with 128 bit block size (16-bytes)
-   three key lengths: 128, 192 and 256 bit
-   security relative to other submitted algorithms
-   efficiency in software and hardware

**Kandidaten**

-   *Mars* by IBM Corporation
-   *RC6* by RSA Laboratories
-   *Rijndael*, by Joan Daemen and Vincent Rijmen
-   *Serpent*, by Ross Anderson, Eli Biham and Lars Knudsen
-   *Twofish*, by Bruce Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall and Niels Ferguson
:::

![](images/crypto/image-8.png){height="4cm" fig-align="center"}

`{\footnotesize $k_{128b  }\rightarrow n_r=10\text{ rounds}\quad k_{192b  }\rightarrow 12\quad k_{256b  }\rightarrow 14$}`{=latex}

![](images/crypto/image-9.png)

![](images/crypto/image-10.png)

Key Addition Layer

:   Ein 128b *Round*-Key/Subkey (vom Hauptkey) wird in das Datenpaket ge**xor**ed (Key Whitening)

Byte Substitution layer (S-Box)

:   Eine Nichtlineare Datentransformation (Konfusion)

Diffusion layer

:   Wendet Diffusion an alle Bits an auf zwei Sublayers an. `\circled{1}`{=latex} *ShiftRows* Layer verändert die Daten auf Byte-Ebene. `\circled{2}`{=latex} *MixColumn* Layer kombiniert/vermischt 4-Byte-Blöcke via Matrix Operationen.

::: callout-warning
Letzte Runde macht **keinen** MixColumn!
:::

::: callout-note
#### Eine AES Runde für Runden $1,2,...,n_r$

![](images/crypto/image-15.png)

Für die Byte Substitution wird folgende S-Box verwendet:

![](images/crypto/image-16.png){width="7cm" fig-align="center"}

**nonlinear** (for mathematical confusion): $f(A)+f(B)\neq f(A+B)$

*Shiftrows* basiert auf folgendem Verschiebungsmuster.

![](images/crypto/shiftrow.pdf)

*MixColumns* wird mit folgender Matrix-Multiplikation gemacht. Analog kann diese Operation auf die anderen Byte-Gruppen gleich angewendet werden.

$$
\begin{bmatrix}
C_0\\ C_1\\ C_2 \\ C_3
\end{bmatrix}=\begin{bmatrix}
\mathtt{02} & \mathtt{03} & \mathtt{01} & \mathtt{01}\\
\mathtt{01} & \mathtt{02} & \mathtt{03} & \mathtt{01}\\
\mathtt{01} & \mathtt{01} & \mathtt{02} & \mathtt{03}\\
\mathtt{03} & \mathtt{01} & \mathtt{01} & \mathtt{02}
\end{bmatrix}\cdot\begin{bmatrix}
B_0\\ B_{5}\\ B_{10} \\ B_{15}
\end{bmatrix}
$$

$\mathtt{01},\mathtt{02},\mathtt{03}$ sind Representationen eines Elements von $GF(2^8)$. **Addition** wird mit XOR Operationen gemacht (1+1+1=1 - ohne Carry!). **Multiplikation** wird mit Polynom Multiplikation gemacht (`\circled{1}`{=latex} Polynom Multiplikation `\circled{2}`{=latex} Modulo Operation).

Beispiel mit Input $\mathtt{25_h,25_h,25_h,25_h}$

![](images/crypto/image-17.png){fig-align="center" height="2.5cm"}
:::

### Key Scheduler / Subkey Generierung

![](images/crypto/image-11.png)

Wie in der Abbildung zu sehen ist, wird das ganz linke *Word* eines Subkeys $W[4i]$, wobei $i = 1,\ldots,10$ ist, wird berechnet als:

$$
W[4i] = W[4(i-1)]+g(W[4i-1])
$$

::: callout-note
#### g-Funktion

Die $g$-Funktion hat zwei Aufgaben. Erstens wird **Nichtlinearität** zum Key Scheduler hinzugefügt. Zweitens wird die **Symmetrie** weggenommen. Beides ist nötig um Block Cipher Attacken zu verhindern.

![](images/crypto/image-12.png){width="7cm" fig-align="center"}

Die $g$-Funktion rotiert die vier input bytes, führt eine byte-weise S-Box substitution und fügt einen Runden-Koeffizient $RC$ dazu. Der Runden-Koeffizient ist ein Element vom Galois field $GF(2^8)$ und wird nur am Byte ganz links dazugefügt. Die Koeffizienten variieren von Runde zu Runde mit folgender Regel:

$$
\begin{split}
RC[~] = [&(\mathtt{0{\times}01})_{16},(\mathtt{0{\times}02})_{16},(\mathtt{0{\times}04})_{16},(\mathtt{0{\times}08})_{16},(\mathtt{0{\times}10})_{16},\\
         &(\mathtt{0{\times}20})_{16},(\mathtt{0{\times}40})_{16},(\mathtt{0{\times}80})_{16},(\mathtt{0{\times}1B})_{16},(\mathtt{0{\times}36})_{16}]
\end{split}
$$
:::

### Entschlüsselung

Da AES keine Feistel Netzwerke besitzt, müssen alle Layers invertiert werden, also schrittweise alles Rückwärts machen. Für die Entschlüsselung wird mit angefangen $k_{10}$ (bei 128b) verwendet, dann $k_9$, $\ldots$.

![](images/crypto/image-13.png)

![](images/crypto/image-14.png)

Bei der Verschlüsselung wird zuletzt der MixColumn **nicht** ausgeführt und ist somit analog daselbe bei der Entschlüsselung einfach am Anfang!

#### Round funktion

Die Sublayers werden ebenfalls verkehrt abgelaufen! Die Inverse der MixColumn Sublayer verläuft auf dem gleichen GF-Prinzip, wiederum einfach umgekehrt.

![](images/crypto/image-18.png)

$$
\begin{bmatrix}
B_0\\ B_1\\ B_2 \\ B_3
\end{bmatrix}=\begin{bmatrix}
\mathtt{0E} & \mathtt{0B} & \mathtt{0D} & \mathtt{09}\\
\mathtt{09} & \mathtt{0E} & \mathtt{0B} & \mathtt{0D}\\
\mathtt{0D} & \mathtt{09} & \mathtt{0E} & \mathtt{0B}\\
\mathtt{0B} & \mathtt{0D} & \mathtt{09} & \mathtt{0E}
\end{bmatrix}\cdot\begin{bmatrix}
C_0\\ C_{1}\\ C_{2} \\ C_{3}
\end{bmatrix}
$$

![](images/crypto/invshiftrow.pdf)

![](images/crypto/invsbox.png){width="7cm" fig-align="center"}

## Cipher Modi [\faWikipediaW](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CTR)

### Electronic Code Book (ECB)

Jeder Block wird separat verschlüsselt.

![](images/crypto/image.png)

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] No block synchronization required
  \item[\color{OliveGreen}$+$] Bit errors only affect the corresponding block
  \item[\color{OliveGreen}$+$] Block cipher operating can be \textbf{parallelized}
  \item[\color{BrickRed}$-$] Plaintext blocks are encrypted independently of previous blocks
  \item[\color{BrickRed}$-$] Identical plaintexts result in identical ciphertexts $\rightarrow$ double sending is detectable
  \item[\color{BrickRed}$-$] An attacker may reorder or exchange ciphertext blocks $\rightarrow$ \textbf{Man in the middle attack}
\end{description}}
```

::: callout-caution
## Substitution Attack on ECB

![](images/paste-35.png)
:::

### Cipher Block Chaining (CBC)

![](images/crypto/image-1.png)

$X_1$ wird by einem öffentlich(!) Initialvektor $IV$ (auch *nonce* $IV$ genannt). Alle weiteren Pakete werden mit dem vorherigen Paket verschlüsselt!

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Ciphertext $y_1$ depends on plaintext $x_1$, the key and the $IV$
  \item[\color{OliveGreen}$+$] Ciphertext $y_i$ depends on \textbf{all} previous plaintext blocks (and $k$, $IV$)
  \item[\color{BrickRed}$-$] No parallelization possible
  \item[\color{BrickRed}$-$] A transmission error destroys \textbf{all} following information
\end{description}}
```

### Output Feedback (OFB)

![](images/crypto/image-2.png)

Block Cipher zu synchronem Stream Cipher (**synchron**: Key stream $S_i$ ist nicht vom Cipher selbst abhängig und somit kann der Key Stream komplett vorgerechnet werden).

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Ciphertext $y_1$ depends on plaintext $x_1$, $k$ and the nonce $IV$
  \item[\color{OliveGreen}$+$] Encryption and decryption is exactly the same operation
  \item[\color{OliveGreen}$+$] Very fast, $S_i$ can be precomputed
  \item[\color{BrickRed}$-$] Ciphertext $y_i$ only depends on plaintext $x_i$, $k$ (not on previous plaintexts)
\end{description}}
```

### Cipher Feedback (CFB)

![](images/crypto/image-3.png)

Block Cipher zu **a**synchronem Stream Cipher (**asynchron**: Key stream $S_i$ ist vom Cipher abhängig und ist daher eher langsamer im Vergleich zu OFB).

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Ciphertext $y_i$ depends on all previous plaintext blocks (and $k$, $IV$)
  \item[\color{BrickRed}$-$] No parallelization possible
\end{description}}
```

### Counter (CTR)

Block Cipher zu synchronem Stream Cipher. $IV$ wird zusammen mit einem Counter zur Key Stream generierung verwendet, was eine Vorberechnung des gesamten Streams erlaubt.

![](images/crypto/image-4.png){height="4cm" fig-align="center"}

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Parallelization is possible (no dependance of previous cypher)!
  \item[\color{OliveGreen}$+$]  Very fast, can be precomputed
  \item[\color{BrickRed}$-$] Ciphertext $y_i$ only depends on plaintext $x_i$, $k$
\end{description}}
```

### Galois Counter Mode (GCM)

![](images/crypto/image-5.png)

Fügt **message authentication & integrity** als CTR-Erweiterung ein. Alle Multiplikationen werden mit dem 128-Bit Galois Feld $GF(2^128)$ und dem irreduziblen Polynom $P(x) = x^{128} +x^7 +x^2 +x+1$ gemacht.

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Authentication data can be left in plain text
\end{description}}
```

::: callout-note
### message authentication & integrity?

...authentication

:   Bob kann prüfen, ob Alice wirklich die Nachricht gesendet hat.

...integrity

:   Bob kann prüfen, dass niemand den Ciphertext während der Übertragung manipuliert hat.
:::

## Double Encrpytion & Meet-In-The-Middle Attack (MITM)

![](images/crypto/image-6.png)

*Double Encryption* wird der Plaintext $x$ zuerst mit $k_L$ verschlüsselt und dann mit $k_R$ folgend entschlüsselt $\rightarrow$ Ciphertext $y$.

*Meet-In-The-Middle Attack*:

1.  **Table Computation** Linke Seite wird via *Brute-Force* den Key $k_L$ ermittelt und daraus ein Lookup Table mit $2^k$ Einträgen erstellt.
2.  **Key Matching** Via *Decryption-Brute-Force* wird die Rechte Seite entschlüsselt und $z_{R,j}$ mit dem entsprechenden Werte von $z_{L,i}$ im Lookuptable verglichen.

Dies reduziert die Komplexizität von $2^{2k}$ zu $2^{k+1}$ Suchoperationen.

## Triple Encrpytion

![](images/crypto/image-7.png)

Der Plaintext wird *encrypted-decrypted-encrypted* (EDE) mit drei verschiedenen Keys. Bei einer Key-Grösse von 56-Bits (168-Bit Key komplett) verlängert sich der Aufwand zurück zu $2^{2k}$ Operationen.

$$
y=e_{k1}(e_{k2}^{-1}(e_{k3}(x)))
$$

Der MITM-Angriff reduziert die [effektive]{.underline} Keygrösse von $3\cdot56=168$ zu 112 Bits.

## Key Whitening

![](images/crypto/keywhitening.pdf){fig-align="center"}

Damit wird DES resistenter gegenüber Brute-Force-Attacken gemacht. Zwei Whitening Keys $k_1$ & $k_2$ werden verwendet. Zum Beispiel DESX verwendet Key Whitening.

::: callout-warning
Schützt den Blockcipher nicht vor **analytischen** Angriffen wie lineare oder differentiale Kryptoanalyse. Daher ist dieser nutzlos bei schwachen Cipher (z.B. DES).
:::

## Asymmetrische Kryptographie

::: callout-note
## Key Lengths and Security

![](images/paste-36.png)
:::

### Key Distribution Problem

Das Problem der symmetrischen Kryptographie ist, dass jeder Teilnehmer eines Kommunikationsnetzwerkes über die Schlüssel aller anderen Teilnehmer verfügen muss.

$$
\#_{keys}(n_{user})=n_{user}\cdot\frac{n_{user}-1}{2}\text{ Key Paare}
$$

![](images/crypto/keyprob.pdf){fig-align="center" height="4cm "}

### Public Key Cryptography [\color{BrickRed}\faYoutube](https://www.youtube.com/watch?v=GSIDS_lvRv4)

-   Key besteht aus **public** und **private** Teile.
    -   **private**: Schlüssel ist nur mir bekannt (**don't share!**)
    -   **public**: Schlüssel ist öffentlich verfügbar
-   Was mit dem **private** key verschlüsselt wird kann mit dem **public** key entschlüsselt werden und vica verca
-   Löst das Key Distribution System! **Aber** ist sehr Rechenintensiv!

![](images/crypto/asyncrypto.pdf){fig-align="center"}

::: callout-caution
#### Man-In-The-Middle Attack [\color{BrickRed}\faYoutube](https://www.youtube.com/watch?v=vsXMMT2CqqE)

![](images/crypto/diffie_problem.pdf){fig-align="center"}

Sean (oder Mallory) fängt den Key (`ga`, `gb`) Austausch zwischen Alice & Bob ab und antwortet beidseitig mit dem eigenen Key (`s`$\rightarrow$`gas`, `gab`). Damit kann Sean jegliche Nachrichten lesen und verändern, ohne dass es Alice & Bob merken.
:::

### Diffie Hellman [\color{BrickRed}\faYoutube${}_1$](https://www.youtube.com/watch?v=NmM9HA2MQGI), [\color{BrickRed}\faYoutube${}_2$](https://www.youtube.com/watch?v=Yjrfm_oRO0w)

![](images/crypto/diffie.pdf){fig-align="center"}

**Vorbereitung**:

1.  Wählen einer **grossen** Primzahl ${\color{OliveGreen}\mathbf{p}}$
2.  Wählen einer **grossen** Ganzzahl ${\color{OliveGreen}\mathbf{g}}\in(2,3,\ldots,n-2)$
3.  ${\color{OliveGreen}\mathbf{p}}$ & ${\color{OliveGreen}\mathbf{g}}$ veröffentlichen

**Ausführung**:

```{=latex}
{\small\begin{description}[parsep=2mm,labelsep=2pt,labelwidth=8pt]
  \item[\textbf{Alice}] \circled{1} Wählen eines zufälligen {\color{BrickRed}\textbf{private}} Key ${\color{BrickRed}\mathbf{a}}$ \\
                        \circled{2} {\color{OliveGreen}\textbf{Public}} Key berechnen: ${\color{OliveGreen}\mathbf{k_{A}}}={\color{OliveGreen}\mathbf{g}}^{\color{BrickRed}\mathbf{a}}~\text{mod}~{\color{OliveGreen}\mathbf{p}}$ \\
                        \circled{3} Key ${\color{OliveGreen}\mathbf{k_{A}}}$ veröffentlichen
  \item[\textbf{Bob}] \circled{1} Wählen eines zufälligen {\color{BrickRed}\textbf{private}} Key ${\color{BrickRed}\mathbf{b}}$ \\ \circled{2} {\color{OliveGreen}\textbf{Public}} Key berechnen: ${\color{OliveGreen}\mathbf{k_{B}}}={\color{OliveGreen}\mathbf{g}}^{\color{BrickRed}\mathbf{b}}~\text{mod}~{\color{OliveGreen}\mathbf{p}}$ \\ \circled{3} Key ${\color{OliveGreen}\mathbf{k_{B}}}$ veröffentlichen
  \item[\textbf{Alice}] Session Key berechnen: ${\color{BrickRed}\mathbf{k_{AB}}}={\color{OliveGreen}\mathbf{k_{B}}}^{\color{BrickRed}\mathbf{a}}~\text{mod}~ {{\color{OliveGreen}\mathbf{p}}}={\color{OliveGreen}\mathbf{g}}^{\color{BrickRed}\mathbf{ab}}~\text{mod}~ {{\color{OliveGreen}\mathbf{p}}}$
  \item[\textbf{Bob}] Session Key berechnen: ${\color{BrickRed}\mathbf{k_{AB}}}={\color{OliveGreen}\mathbf{k_{A}}}^{\color{BrickRed}\mathbf{b}}~\text{mod}~ {{\color{OliveGreen}\mathbf{p}}}={\color{OliveGreen}\mathbf{g}}^{\color{BrickRed}\mathbf{ab}}~\text{mod}~ {{\color{OliveGreen}\mathbf{p}}}$
\end{description}}
```

Um die Verschlüsselung zu knacken, müsste Oskar (the bad guy) '$g^a ~\text{mod}~ n = k_A$' oder '$g^b~\text{mod}~ n = k_B$' faktorisieren.

![](images/crypto/image-19.png){height="2cm" fig-align="center"}

::: {.callout-tip appearance="simple"}
#### Beispiel

![](images/crypto/image-20.png){width="7cm" fig-align="center"}

**!!!** Jedes weitere bit in $p$ verdoppelt den nötigen Aufwand um einen Private Key zu finden **!!!**
:::

### Elgamal Encryption Scheme

Erweiterung von DHKE $\rightarrow$ Ähnlicher Ablauf wie bei DHKE, einfach wird ein neuen private Key für jeden Block generiert! Dies **verdoppelt** die benötigte Sende-Bandbreite, dafür können die Schlüssel vorgerechnet werden (Im Beispiel auf Alice bezogen)!

![](images/crypto/image-21.png){width="8cm" fig-align="center"}

```{=latex}
{\footnotesize\begin{description}[parsep=0mm,labelsep=2pt,labelwidth=8pt]
  \item[\color{OliveGreen}$+$] Alice can precompute many keys $k_{AP}$ (and send them to Bob from him to precompute $k_{AB}$)
  \item[\color{BrickRed}$-$] Bandwidth requirement*2 ($y$ and $k_{AP}$ for each block)
\end{description}}
```

### RSA

**Vorbereitung**:

1.  **Zwei grosse** Primzahlen ${\color{BrickRed}\mathbf{p}}$, ${\color{BrickRed}\mathbf{q}}$
2.  Berechne den `{\color{OliveGreen}\text{public}}`{=latex} Wert ${\color{OliveGreen}\mathbf{n}}={\color{BrickRed}\mathbf{p}}\cdot {\color{BrickRed}\mathbf{q}}$ (one way *trapdoor* function)
3.  Berechne ${\color{BrickRed}\phi} ({\color{OliveGreen}\mathbf{n}})=({\color{BrickRed}\mathbf{p}}-1)\cdot({\color{BrickRed}\mathbf{q}}-1)$
4.  Wählen des `{\color{OliveGreen}\text{public}}`{=latex} Exponenten ${\color{OliveGreen}\mathbf{e}}\in\{1,2,\ldots,{\color{BrickRed}\phi}({\color{OliveGreen}\mathbf{n}})-1\}$ sodass $\text{gcd}({\color{OliveGreen}\mathbf{e}},{\color{BrickRed}\phi}({\color{OliveGreen}\mathbf{n}}))=1$ (**g**reatest **c**ommon **d**ivisor)
5.  `{\color{OliveGreen}\text{private}}`{=latex} Key ${\color{BrickRed}\mathbf{d}}$ sodass $({\color{BrickRed}\mathbf{d}}\cdot {\color{OliveGreen}\mathbf{e}})~\text{mod}~ {\color{BrickRed}\phi}({\color{OliveGreen}\mathbf{n}})=1$ gilt

**Ausführung**:

```{=latex}
{\small\begin{description}[parsep=2mm,labelsep=2pt,labelwidth=8pt]
  \item[\textbf{Alice}] Verschlüsselt $y=x^{\color{OliveGreen}\mathbf{e}}~\text{mod}~{\color{OliveGreen}\mathbf{n}}$
  \item[\textbf{Bob}] Verschlüsselt $x=y^{\color{BrickRed}\mathbf{d}}~\text{mod}~{\color{OliveGreen}\mathbf{n}}$
  \item[\textbf{Oskar}] Muss Faktor ${\color{OliveGreen}\mathbf{n}}$ aufwenden, um ${\color{BrickRed}\mathbf{d}}$ zu erhalten
\end{description}}
```

::: {.callout-tip appearance="simple"}
#### Beispiel

![](images/crypto/image-22.png){width="8cm" fig-align="center"}
:::

::: callout-warning
## RSA is malleable

**The Problem**: Textbook RSA allows attackers to manipulate encrypted values without knowing the private key.

**How it Works**:

1.  Attacker has original ciphertext: $c = m^e mod n$

2.  Attacker chooses multiplier: $s$

3.  Attacker computes: $c' = c \cdot s^e mod n$

4.  When decrypted: $(c')^d = m \cdot s mod$

**The Formula**:

$c' = c \cdot s^e mod n (c')^d = (c \cdot s^e)^d = c^d \cdot s^{ed} = m \cdot s mod n$

**Result**: The attacker successfully transforms an encryption of $m$ into an encryption of $m \cdot s$ without knowing $m$ or the private key.

**Real Impact**: An attacker can multiply any encrypted value (money amounts, user IDs, etc.) by any chosen factor.

**Defense**: Use padding schemes like PKCS#1 OAEP that add structured randomness, making it virtually impossible for modified ciphertexts to decrypt to valid padded messages.
:::

::: callout-important
#### Side Channel Attacks

Ein *Side Channel Attack* oder Seitenkanalangriff ist eine Sicherheitslücke, die darauf abzielt, Informationen von einem System zu sammeln oder die Programmausführung eines Systems zu beeinflussen, indem indirekte Effekte des Systems oder seiner Hardware gemessen oder ausgenutzt werden, anstatt das Programm oder seinen Code direkt anzugreifen.
:::

### Eliptic-Curve-Cryptography (ECC)

Die Eliptic-Curve-Cryptography ist einer vieler Ansätze, um einen Public Key zu generieren. Dieser Ansatz verwendet die Struktur einer eliptischen Kurve, um anhand 'Ketten-Schnittpunkten' einen möglichst lange Kette abzulaufen. Das Endprodukt dabei ist ein kürzerer Key, welcher aber gleichwertige Sicherheit im Vergleich zu Nicht-ECC-Verfahren bietet.

::: callout-tip
## Number Lists

Die Modulo funktion `mod` in vorhergehenden Algorithmen ist auch eine Kurve (Kreis von 0 bis n), jedoch eine immer wieder wiederhohlende liste an Integern. Dieses wiederholen verschleiert die ausgangsvariable (z.B. $g^b$) und macht so die berechnung von $b$ extrem schwierig. Der Ansatz über ECC ist noch komplizierter (und sicherer -\> weniger bits für selbe Sicherheit).
:::

#### Addition $P \neq Q$

![](images/crypto/image-25.png){width="6cm" fig-align="center"}

$$
\begin{split}
R(x_3,y_3) &= P(x_1,y_1) + Q(x_2,y_2) \\
\text{slope } s &= (y_2-y_1)/(x_2-x_1) ~\text{mod}~ p \\
x_3 &= s^2-x_1-x_2 ~\text{mod}~ p \\
y_3 &= s\cdot(x_1-x_3)-y_1 ~\text{mod}~ p \\
\end{split}
$$

-   Linie $PQ$ schneidet die Ellipse $E$ an einem dritten Punkt $R'$.
-   $R=P+Q ~\rightarrow$ ist die Inverse von $R’$ (gespiegelt an der X-Achse)

#### Addition $P = Q$

![](images/crypto/image-23.png){width="6cm" fig-align="center"}

$$
\begin{split}
R(x_3,y_3) &= P(x_1,y_1) + P(x_1,y_1)\\
s &= \text{tangent} = (3\cdot x_1^2+a)/(2\cdot y_1) ~\text{mod}~ p\\
x_3 &= s^2-x_1-x_2 ~\text{mod}~ p \quad\qquad {\small\text{wie bei } P\neq Q}\\
y_3 &= s\cdot (x_1-x_3)-y_1 ~\text{mod}~ p \quad {\small\text{wie bei } P\neq Q}\\
\end{split}
$$

::: callout-important
## Trapdoor: Double-and-Add for $d\cdot P$

![](images/paste-37.png)
:::

### Eliptic-Curve Diffie-Hellmann Key Exchange (ECDH)

![](images/crypto/image-24.png)

## Security Services

1.  **Confidentiality**: Information is kept secret from all but authorized parties
2.  **Integrity**: Ensures that a message has not been modified in transit
3.  **Message authentication**: Ensures that the sender of a message is authentic (An alternative term is data origin authentication)
4.  **Non-repudiation**: Ensures that the sender of a message can not deny to be the creation of the message. (e.g. order of a pink car)
5.  **Identification/entity authentication**: Establishing and verification of the identity of an entity, e.g. a person, a computer, or a credit card
6.  **Access control**: Restricting access to the resources to privileged entities
7.  **Availability**: The electronic system is reliably available
8.  **Auditing**: Provides evidences about security relevant activities, e.g., by keeping logs about certain events
9.  **Physical security**: Providing protection against physical tampering and/or responses to physical tampering attempts
10. **Anonymity**: Providing protection against discovery and misuse of identity

## RSA Signature Scheme

Die Schlüssel anhand RSA generieren!

```{=latex}
{\small\begin{description}[parsep=2mm,labelsep=2pt,labelwidth=8pt]
  \item[\textbf{Bob} erzeugt die Signatur] "Verschlüsselt" die Nachricht ${\color{OliveGreen}\textbf{x}}$ \texti{mit} dem \textit{private Key} ${\color{BrickRed}\mathbf{d}}$ \\
                    ${\color{OliveGreen}\mathbf{s}}=\text{sign}_{\color{BrickRed}K_{Priv}}({\color{OliveGreen}\textbf{x}})={\color{OliveGreen}\textbf{x}}^{\color{BrickRed}\textbf{d}} ~\text{mod}~ {\color{OliveGreen}\textbf{n}}$ \\
                    Anhängen der Signatur ${\color{OliveGreen}\textbf{s}}$ an die verschlüsselte Nachricht ${\color{OliveGreen}\textbf{x}}$
  \item[\textbf{Alice} verifiziert die Signatur] \textit{Entschlüsselt} die Signatur \textit{mit} Bob's \textit{öffentlichen Key} (${\color{OliveGreen}\textbf{n}}$,${\color{OliveGreen}\textbf{e}}$) \\
  ${\color{OliveGreen}\mathbf{x}}'=\text{verif}_{\color{OliveGreen}K_{Pub}}({\color{OliveGreen}\textbf{s}})={\color{OliveGreen}\textbf{s}}^{\color{OliveGreen}\textbf{e}} ~\text{mod}~ {\color{OliveGreen}\textbf{n}}$
  \end{description}}
```

Die Signatur ist gültig wenn ${\color{OliveGreen}\mathbf{x}}={\color{OliveGreen}\mathbf{x}}'$

**Benötigt Padding**: Oscar in der Mitte kann verschiedene & gültige Signaturen generieren, in dem er eine eigene Signatur $s\in Z_n$ wählt und $x=s^e~\text{mod}~n$ berechnet. **Jedoch** kann er keine eigene gültige Nachricht erstellen.

## Digital Signature Algorithm (DSA)

![](images/crypto/image-26.png)

![](images/crypto/image-27.png)

![](images/crypto/image-28.png)

![](images/crypto/image-31.png)

::: callout-note
-   Federal US Government standard for digital signatures (DSS) by NIST

Based on Elgamal

:   `$+$`{=latex} Signature is only 320 bits long \| `$-$`{=latex} Slower than RSA signature scheme
:::

### Elliptic Curve Digital Signature Algorithm (EC-DSA)

-   DSA auf der Grundlage der Elliptischen Kurven-Kryptographie (ECC)
-   Bitlängen im Bereich von 160-256 Bit können gewählt werden, um eine Sicherheit zu erreichen, die der von RSA mit 1024-3072 Bit entspricht (symmetrische Sicherheitsstufe 80-128 Bit)
-   Eine Signatur besteht aus zwei Punkten, d. h. die Signatur ist doppelt so lang wie die verwendete Bitlänge (d. h. 320-512 Bit für die Sicherheitsstufe 80-128 Bit).
-   Die kürzere Bitlänge von ECDSA führt oft zu einer kürzeren Verarbeitungszeit

## Key Freshness

Key Freshness... (change keys frequently)

-   Limited damage if a key is exposed but was changed often
-   Attacks are more difficult if the ciphertext for one key is limited
-   Attackers must recover several keys for long pieces of ciphertext ... with Key Derivation
-   derive multiple session keys $k_{ses}$ from a given key $k_{AB}$ and $a$ nonce $r$ ("number used only once")

## Key Distribution Center (KDC)

**Problem:** Jeder benötigt den key von jedem.

![](images/crypto/image-32.png)

## Asymmetric Key Distribution (DHKE, RSA, ECDSA…)

### Certifying Authority (CA)

```{=latex}
{\small\begin{description}[parsep=2mm,labelsep=2pt,labelwidth=8pt]
  \item[Role:] Issues certificates like sigKCA(kpub, …)
  \item[Trust:] Must be trusted by all users.
  \item[Certificate:] Contains public key and user ID with CA's digital signature (e.g., $Cert_Alice$ = ($k_{pub}$, $ID_{Alice}$, $sig_{KCA}$($k_{pub}$, $ID_{Alice}$))), binding identity to key.
  \item[Security Risk:] Vulnerable to man-in-the-middle attacks if the attacker (Oscar) replaces the public key during communication.
  \item[Verification:] Requires the CA's public key, which must be distributed over an authenticated channel.
  \item[Distribution:] CA public key is typically distributed once during system setup (e.g., pre-installed in web browsers).
  \item[Weakness:] Initial transmission of CA public key is not authenticated.
  \item[Standard:] X.509 is a common standard with fields like serial number, algorithm, issuer, validity dates, subject, subject's public key, and signature.
\end{description}}
```

## Hash Functions

![](images/paste-38.png)

### SHA-1

![](images/paste-39.png)

### SHA-3 (Keccak)

Bit's werden mit jeder Iteration verstrichen (ein Bit besteht aus hunderten Bits) -\> Rückwärts nicht rechenbar.

![](images/paste-40.png)

## weitere Begriffe

```{=latex}
{\small
\textbf{Keyspace} Anzahl möglichen \& relevanten Keys

\textbf{Brute Force} Alle Keykombination versuchen (Erfolg $\approx$ Keyspace/2)

\textbf{Frequency Analysis} Gewisse Zeichen(kombinationen) werden häufiger verwendet 

}
```

# Security

::: callout-note
## Cybersecurity

-   Increased connectivity and complexity
-   Missing Awareness
-   Basics mostly not implemented

**Issues**: IP stealing, clones / HW stealing, re-purposing / Loss of Data / Affected production time, customer, ... / Damaged equipment / Killing people / Reputation damaged

**HW mitigation**: MCU security features / Software-only security / HW security (bsp. TPM) / Secure storage / Dedicated security IC / HW security module (supply chain) / Mitigation for side-channel attacks
:::

**Control through Supplier Hack**: Hack a supplier and then control their products (John Deere, IP-cameras, Viasat terminal on wind turbines)

**Physical Access**: Mitigation through Security mesh (card terminals) -\> if case broken -\> circuit broken / Fake microcontrollers with possible back door or HW limitations (schindler STM32) / Direct memory read out (ThingDust)

**Spoofing**: Overload sensors to report wrong values, wrong times -\> robust sensor computations

# Reliability

::: callout-important
## Pillars of Dependability

-   Availability
-   Reliability
-   Safety
-   Security

## Information Security: CIA

-   **Confidentiality**: How is information protected
-   **Integrity**: What could compromise the system, life-cycle
-   **Availability**: What could take the system down

## Cyber-Security Terms

-   **Attack Vector**: path to compromise a system
-   **Attack Surface**: End goal of the attack vector
-   **Threat Actor**: source with malicious intent
-   **Attacker**: individual performing malicious act in real time
-   **Vulnerability**: Weakness that can be exploited
:::

::: callout-note
## Attack Vectors

Weak Credentials / Phishing Attacks / Malware / Driver Vulnerabilities / Brute Force Attacks / Distributed Denial of Service (DDoS) / Social Engineering / Bus Sniffing / Memory Readout / Malicious Update / Buffer Overflow / Signal Jamming / Power Analysis / Electromagnetic Analysis
:::

## Stuxnet - How to kill a centrifuge

![](images/paste-43.png)

![](images/paste-44.png)

1.  **Infection**: Computer with USB stick and stolen certificate
2.  **Search**: Siemens SCADA -\> Re-incetion -\> Propagation
3.  **Update**: from infection source
4.  **Compromise**: through *zero day* vulnerability of printer
5.  **Control** target after getting information -\> take control
6.  **Deceive**: False feedback and **Destroy** through spinning

# Vulnerability

::: callout-note
## Binary Exploitation

-   **Buffer Overflow**: Writing more data to a buffer than it can hold -\> overwrite data -\> crash / take control
-   **Memory Corruption**: Write memory in unintended way -\> crash / take control
-   **Return Address Modification**: Overwrite function return address to redirect program flow
-   **Code Injection**: Malicous Code to crash / take control
-   **Format String Vulnerability**: Use Stdlib functions like `printf()` to read and write target memory
:::

## Attack Vector: Format String Vulnerability

Format string vulnerabilities occur when user input is passed directly as the format string to printf-family functions, allowing attackers to read from and write to arbitrary memory locations through format specifiers.

### Reading Memory at Specific Positions

Attackers can use positional parameters to read specific stack locations:

``` c
// Vulnerable code
char buffer[100];
int secret = 0xdeadbeef;
fgets(buffer, sizeof(buffer), stdin);
printf(buffer);  // Vulnerable call
```

**Attack Examples:** - `%x` - Read next stack value as hex - `%7$x` - Read 7th argument position as hex\
- `%10$s` - Read 10th position as string pointer - `%2$llx` - Read 2nd position as 64-bit hex

**Example Attack:**

``` c
// If buffer contains "%6$x", it might leak the secret variable
// Input: "%6$x" 
// Output: "deadbeef" (leaking the secret value)
```

### Writing Memory at Specific Positions

The `%n` specifier writes the number of characters printed so far to a memory address:

``` c
// Vulnerable code with pointer on stack
char buffer[100];
char *target = (char*)0x08048000;  // Target address
fgets(buffer, sizeof(buffer), stdin);
printf(buffer);
```

**Write Techniques:** - `%n` - Write 4-byte integer - `%hn` - Write 2-byte short - `%hhn` - Write 1-byte char - `%ln` - Write long integer

**Example Attack:**

``` c
// To write value 1337 to address pointed by 6th stack position:
// Input: "%1337c%6$n"
// This prints 1337 characters, then writes 1337 to address at position 6

// For precise control, attackers often split writes:
// Input: "%300c%6$hhn%37c%7$hhn" 
// Writes 300 to first byte, 337 to second byte of target address
```

**Advanced Write-What-Where:** Attackers can control both the value written and the target address by placing addresses on the stack and using positional parameters to reference them, enabling arbitrary code execution through techniques like GOT overwrites or return address modification.

The vulnerability's power lies in printf treating user input as instructions rather than data, breaking the fundamental security principle of data/code separation.

::: callout-important
## Attack Vector: Read and write specific address

-   1: Plant the Target Address Place the target memory address (e.g., `0x01020304`) at the beginning of your format string input as raw bytes: `\x04\x03\x02\x01`

-   2: Find Format String Position Use test input like `"AAAA_%x_%x_%x_%x"` to determine which stack position contains your format string (look for `41414141` in output)

-   3: Stack Walk to Planted Address Use the appropriate number of `%x` format specifiers to advance printf's argument pointer through stack positions until it reaches the location containing your planted address

-   4: Execute Memory Operation

-   **For Reading**: Use `%s` to read memory starting at your planted address

-   **For Writing**: Use `%n` to write the current character count to your planted address

**Example Complete Attack:**

``` c
// To write value 500 to address 0x01020304:
user_input = "\x04\x03\x02\x01%x%x%x%0496x%n"
//           ^target addr  ^walk to it ^pad to 500 chars ^write 500
```

**Key Insight:** The vulnerability exploits the fact that your malicious format string gets stored on the stack, allowing you to plant controlled addresses that `printf` will later interpret as legitimate arguments during its sequential argument processing.
:::

::: callout-tip
## Countermeasures

Outputting user data through

``` c
printf("s%", user_input)
```

converts the input data into a string and no string string format vulnerability is possible.

**Attention**: Buffer overflow is still possible, NULL termination (\\x00) might truncate the output
:::

# Attack Vector: Binaries

## Binary File Formats

-   Used by debugging tools: **ELF/DWARF**: Standard executable format with debug information (*.axf, .elf* files)
-   **S-Record**: Motorola text format with type, address, data, and checksum (.*s19*, *.sx*)
-   **Intel Hex**: Text format with similar structure (.*hex*)
-   **Binary**: Raw memory content with optional offset (.*bin*)
-   **UF2**: Format for USB Mass Storage Device bootloaders

## Memory Operations and Debugging

## Flash Security Features

**Protection Mechanisms:**

-   Special configuration bits read during MCU boot to enable read-out protection
-   Mass-erase protection for intellectual property security
-   Designed as protection rather than true security features
-   Careful bit combinations required to avoid accidental device bricking

**Kinetis Flash Configuration:**

``` c
Flash_Config = {
    0xFFFFFFFF, / * backdoor key * / 
    0xFFFFFFFF, / * backdoor key * / 
    0xFFFFFFFF, / * NV Protection * /
    ((0xffff)<<16) / * reserved (2 bytes) * / 
    / * flash option register byte (FOPT), RM page 177: * / 
    | (0b1<<13) / * FAST_INIT: 0: slow, 1: fast * / 
    | (0b11<<11) / * reserved * /
    | (0b1<<10) / * NMI: 0: disabled, 1: enabled * / 
    | (0b1<<9) / * EZPORT: 0: disabled, 1: enabled * /
    | (0b1<<8) / * LPBoot: 0 low power boot; 1 normal boot * / 
    / * flash security byte (FSEC), RM page 640: * /
    | (0b11<<6) / * 11 backdoor key access disabled; 00,01,10: enabled * / 
    | (0b11<<4) / * 11,00,01: mass erase enabled, 10: disabled * / 
    | (0b11<<2) / * 11: factory access granted, 00,01,10 denied * / 
    | (0b10<<0) / * 10: unsecure, 11,00,01: secure * / //-> bricked if mass erase is disabled
};
```

## Backdoor Access System

-   64-bit backdoor key stored in flash configuration
-   Application can request user input for key verification
-   Successful authentication temporarily disables flash security until reboot
-   Connect through debugger **without reset**
-   **Critical Warning**: Unknown backdoor key with disabled mass-erase results in permanently bricked device

## Reverse Engineering with Ghidra

**NSA's Open-Source Tool:**

-   Eclipse-based reverse engineering suite for analyzing compiled binaries
-   Provides disassembly, decompilation, and annotation capabilities
-   Can analyze both debug-enabled and stripped binaries

**Analysis Workflow:**

1.  Import binary files into Ghidra project
2.  Set appropriate CPU architecture (ARM Thumb)
3.  Navigate from vector table to ResetISR() and main()
4.  Use debug-enabled versions as blueprints for understanding stripped binaries

# Attack Vector: Memory

## Memory Protection Motivations

-   **Security Risks**: IP and key stealing, reverse engineering, malicious code execution
-   **Runtime Errors**: Stack overflow, dangling pointers, buffer overflows
-   **System Integrity**: Configuration modification, virus code execution, supply chain attacks
-   **Development Concerns**: Commissioning/production issues, bootloader security, trusted vs non-trusted partitioning, supply chain control (# of units)

## Protection Concepts

**Internal Firmware Protection:**

-   Flash security features (Kinetis, STM32, etc.)
-   Execute-only code regions (deprecated on Kinetis -\> cpu muss lesen, aber es darf nicht gelesen werden **CPU glitch**)
-   Secure and non-secure domains (ARM Cortex-M33 TrustZone)

**External Memory Protection:**

-   Secure external flash memory
-   Secure elements for cryptographic operations
-   Encrypted external bus protocols (CAN, UART, I2C)
-   Tamper detection and destruction mechanisms

## MMU vs MPU Architecture

**MMU (Memory Management Unit) - ARM Cortex-A:**

![](images/paste-45.png)

-   **Required for Linux operating systems**
-   Provides virtual memory with on-demand paging
-   Maps program addresses into separate physical memory areas
-   Supports complex memory management with file system integration

**MPU (Memory Protection Unit) - ARM Cortex-M:**

![](images/paste-46.png)

-   Limited functionality due to limited silicon area
-   Limited number of configurable regions (8-16 depending on variant)
-   Access permissions (R/W/X) based on privilege levels (**privileged**/**unprivileged**)
-   Hardfault at memory access violation
-   Can only be configured by privileged code

![](images/paste-48.png){fig-align="center" width="6cm"}

## ARM Cortex-M MPU Evolution

![](images/paste-49.png)

**ARMv7-M (PMSAv7) Limitations:**

-   Up to 8 regions (M0+/M3/M4) or 16 regions (M7)
-   Restrictive power-of-two region sizes (minimum 32 bytes)
-   Strict 32-byte alignment requirements
-   Limited flexibility for real-world applications

**ARMv8-M (PMSAv8) Improvements:**

-   More flexible region numbers: 0, 4, 8, 12, or 16 regions
-   Start + end addressing instead of start + 2\^n bytes
-   Memory Attribute Indirection Register (MAIR) for shared attributes
-   Banked register sets for Secure and Non-Secure modes

## Security Applications

**MPU-Enabled Protection Mechanisms:**

-   **Code Integrity Protection (CIP)**: Prevents code injection by making code regions non-writable
-   **Data Execution Prevention (DEP)**: Marks data regions (stack/heap) as non-executable
-   **Stack Guard (SG)**: Creates red zones at stack boundaries to detect overflows
-   **Kernel Memory Isolation (KMI)**: Prevents unprivileged code from accessing kernel space
-   **User Task Memory Isolation (TMI)**: Isolates tasks from each other's memory
-   **Peripherals Isolation (PI)**: Restricts peripheral access based on privileges

## Implementation Challenges

-   Optional ARM feature that may not be implemented by all vendors
-   RTOS adoption has faced integration challenges
-   Overhead in code size and RAM usage due to alignment gaps
-   Complexity with DMA operations, vector tables, and privilege escalation
-   Insufficient protection against sophisticated hacker attempts

# Attack Vector: Debugger

-   **Intellectual Property Theft**: Extracting proprietary code and algorithms
-   **Product Cloning**: Creating unauthorized copies of embedded devices
-   **Reverse Engineering**: Understanding system functionality and vulnerabilities
-   **Custom Firmware Installation**: Modifying device behavior through unauthorized code

**Attack Scenarios:**

-   **Use Case 1**: Debugging crashed or halted applications for legitimate troubleshooting
-   **Use Case 2**: Malicious reverse engineering of production devices
-   **Attach Operations**: Inspecting target systems without reprogramming, using existing firmware

## Debug Interface Vulnerabilities

-   **SWD (Serial Wire Debug)**: Uses Clock and DataInOut pins
-   **JTAG**: Requires DataIn, DataOut, Clock, and Select pins
-   **Reset Line**: Allows debugger to halt device execution immediately after reset

**Debug Capabilities:**

-   **With Debug Information**: Full source-level debugging with symbol mapping
-   **Without Debug Information**: Assembly-level debugging still possible
-   **VS Code Integration**: Toggle between source and disassembly views for analysis

## Countermeasures and Protection Strategies

### Flash Security Implementation:

-   Configure flash security with or without mass erase capability
-   Prevent unauthorized firmware reading and modification

### Debug Authentication:

-   Password-based protection for debug access
-   Requires valid credentials before allowing debugger connection

### Hardware-Level Protection:

-   **Disabled Debug Block**: Use MCU fuses to permanently disable debugging
-   **PCB Design**: Remove debug pins/headers from production boards
-   **Pin Obfuscation**: Hide or disguise debug connection points

### Debug Pin Muxing Defense

**Implementation Strategy:**

-   Reconfigure debug pins as GPIO or disconnect them in firmware
-   Execute muxing code in startup sequence before main application
-   Implement backdoor access for legitimate debugging needs

**Attack Window Limitations:**

-   **Defender Advantage**: Debug pins disabled after reset sequence
-   **Attacker Challenge**: Must halt device within small time window
-   **Advanced Attacks**: May require voltage glitching or reset manipulation

# Glitching & Fault Injection

**Attack Principle:** Glitching exploits the fact that digital devices require stable operating conditions to function correctly. When these requirements aren't met, devices may fail in predictable ways that can be exploited.

**Common Fault Injection Methods:**

-   **Voltage Glitching**: Temporarily altering the supply voltage
-   **Clock Manipulation**: Changing timing of system clock signals
-   **Electromagnetic Pulses**: Localized high-intensity electromagnetic interference
-   **Optical Attacks**: Exposing silicon die to specific light wavelengths
-   **Temperature Attacks**: Operating devices outside thermal specifications

**Exploitation Outcomes:**

-   Instruction skipping or incorrect execution
-   Failed data fetch or write-back operations
-   Incorrect instruction decode
-   Bypassing security checks

## Attack Parameters and Timing

**Critical Timing Controls:**

-   **Offset**: Delay from trigger signal to glitch execution (\~8.3 ns precision)
-   **Repeat**: Duration of the glitch pulse (\~8.3 ns precision)
-   **Jitter**: Asynchronous timing variation up to \~200 ns

![](images/paste-50.png)

**Optimization Challenges:**

-   Glitches too short produce no effect
-   Glitches too long cause system crashes or resets
-   Only narrow parameter bands yield successful attacks
-   Results can be inconsistent, requiring patience and repeated attempts

# Side-Channel: Power Analysis

![](images/paste-51.png){fig-align="center" width="5cm" height="1.5cm"}

-   Measure power consumption during code execution using ADC sampling
-   Trigger signals synchronize measurements with specific code execution points
-   Python Jupyter Notebooks provide interactive analysis environment

## Power Consumption Patterns

Different CPU operations exhibit distinct power signatures:

**Multiplication Operations:**

``` c
volatile long int A = 0x2BAA;
A *= 2;  // Repeated 20 times
```

Assembly shows simple left-shift operations (`lsls r3, r3, #1`) with predictable power patterns.

**Division Operations:**

``` c
A /= 3;  // More complex
```

Division requires significantly more computational resources and produces heavier power consumption compared to multiplication.

**Loop vs Unrolled Code:**

Both approaches show different power signatures despite identical mathematical operations

-   **Unrolled**: 20 individual multiplication statements
-   **Loop**: `for(i=0; i<20; i++) A*=2;` with loop overhead

![20 Mul (blau) / Mul Loop (Rot)](images/paste-52.png)

**Attack Results:**

Character-by-character analysis reveals correct password characters by comparing power trace differences:

![](images/paste-53.png)

## Laboratory Implementation

**Hardware Setup:**

-   ChipWhisperer-Nano platform with on-board STM32F0 target
-   ARES_PowerAnalysis Jupyter Notebook environment
-   Power measurement capabilities synchronized with code execution
-   Interactive parameter adjustment and trace visualization

**Practical Exercises:**

1.  **Power Measurement**: Analyze consumption patterns for different operations
2.  **Trace Capture**: Record and visualize power signatures using `capture_trace()` function
3.  **Password Attack**: Implement automated password guessing via power analysis
4.  **Countermeasure Analysis**: Explore what makes attacks successful and potential defenses

## Security Implications

**Attack Effectiveness:** Power analysis can reveal:

-   Cryptographic operations (AES implementations have distinct signatures)
-   Secret data through differential power analysis
-   Program execution flow and timing information
-   Authentication bypass opportunities

**Key Vulnerabilities:**

-   Early termination in comparison loops
-   Data-dependent power consumption
-   Insufficient power consumption randomization
-   Predictable execution patterns